
What is NoSQL?
	-> A NoSQL database refers to a non-relational database that is short for non SQL and Not only SQL.
	->  It is a data-storing and data-retrieving system. NoSQL databases are commonly used nowadays for big Data and IoT devices due to their powerful features such as fast queries, ease of use to developers, scale easily, and flexible data structure. 

Understanding NoSQL?
	-> Various types of NoSQL databases can be covered, including MongoDB, Couchbase, RavenDB, etc.
	
	MongoDB
		-> Similar to relational databases (such as MySQL and MSSQL), MongoDB consists of databases, tables, fields but with different names where 

			1. Collections are similar to tables or views in MySQL and MSSQL.
    		2. Documents are similar to rows or records in MySQL and MSSQL.
    		3. Fields are similar to columns in MySQL and MSSQL.

    	-> Documents in MongoDB are objects stored in a format called BSON, which supports JSON data types for document storing.
    	-> Also, it is useful to briefly look at and compare the query operators between MongoDB and MySQL

    		    1. $and equivalent to AND in MySQL
    			2. $or equivalent to OR in MySQL
    			3. $eq equivalent to = in MySQL

Interacting with MongoDB server:
	Default port: 27017
	> show databases - list databases
	> use [database name]
		- used to connect to a database if it exists or create a new one if it doesn't exist.
	> db.createCollection("users") - create a table named users
	> db.getCollectionNames(); = list all tables

	>db.collectionName.insert({fieldName:[value],.....})
	>db.collectionName.find() - list all documents within the collection

	-> MongoDB automatically creates a unique ID called _id for each document within the collection.

	>db.collectionName.update({id:"2"},{$set: {username: "tryhackme"}});
	>db.collectionName.remove({id:"2"}) - removes the document with id 2
	>db.collectionName.drop() - deletes the collection/table.

NoSQL Injection:
	-> NoSQL injection is a web security vulnerability that allows the attacker to have control over the database. A NoSQL injection happens by sending queries via untrusted and unfiltered web application input, which leads to leaked unauthorized information.

	->  In addition, the attacker can use the NoSQL injection to perform various operations such as modifying data, escalating privileges, DoS attacks, and others.

Bypassing Login pages:
	-> The logic of login pages is similar in most databases: first, connect to the database and then look for a certain username and password; if they exist in the collection (in the database), then we have a valid entry.
	-> The following is the query that is used in the web applications used on our login page:  db.users.find({query}) or db.users.findOne(query)  functions where the query is JSON data that's send via the application:  {"username": "admin", "password":"adminpass"}

	-> Note that when we provide the correct credentials, a document returns, while a null reply is received when providing the wrong credentials when nothing matches!


	-> Before exploiting the NoSQL injection, there are MongoDB operators that we need to be familiar with that are heavily used in the injections, which are:
		$eq - matches records that equal to a certain value
		$ne - matches records that are not equal to a certain value
		$gt - matches records that are greater than a certain value.
		$where - matches records based on Javascript condition
		$exists - matches records that have a certain field
		$regex - matches records that satisfy certain regular expressions.

	Example:
		-> we will be exploiting the logic of the login query by injecting a JSON object which includes one of the NoSQL operators, which is $ne. 

		> db.users.findOne({username: "admin", password: {"$ne":"xyz"}})
		{
        "_id" : ObjectId("6183ef6292dea43d75f0c820"),
        "id" : "1",
        "username" : "admin",
        "email" : "admin@thm.labs",
        "password" : "adminpass"
		}

		-> We injected a JSON objection {"$ne": "XYZ"}  in the password field, and we changed the logic to become as follows:
			 We are telling MongoDB to find a document (user) with a username equal to admin and his password is not equal to xyz, which turns this statement to TRUE because the admin's password is not xyz.

		-> Now let's say if we wanted to log in to a system as another user who is not admin. In this case, we can also inject into a username field to be as follows,

		> db.users.findOne({username:{"$ne":"admin"},password:{"$ne":"xyz"}})
		{
        "_id" : ObjectId("6183ef5b92dea43d75f0c81f"),
        "id" : "2",
        "username" : "user",
        "email" : "user@thm.labs",
        "password" : "password1!"
		}

		-> If this were a login page, we would be logged in as a not admin, which is the user. We injected two JSON objects into a username as well as password fields: we are telling MongoDB to find a document that its username is not equal to admin and its password is not equal to xyz, which returns the statement as true.


Exploiting NoSQL Injection
	-> To exploit NoSQL injection within the web application, first, you need to find an entry point that doesn't sanitize the user's input.
	-> Next, you need to understand how the web application passes the request to the database! Once you find an entry point, passing queries could be varied.
	-> Sometimes, the web app accepts the user's input via GET or POST queries, and sometimes web applications accept a JSON object, as is the case with APIs.

	-> Injecting a NoSQL query has different forms if we deal with GET or POST queries than JSON objects but still have the same concept.
	-> Let's discuss how to inject into regular  GET or POST requests.
	-> To interact with MongoDB via GET or POST is by injecting an array of the MongoDB operator to match the JSON objection to match the Key: Value.

	-> The following is an example of how to inject via URL:
	   	http://example.thm.labs/search?username=admin&role[$ne]=user

	   