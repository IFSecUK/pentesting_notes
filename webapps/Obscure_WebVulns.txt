SSTI (Server Side Template Injection):
	-> A template engine allows developers to use static HTML pages with dynamic elements. 
	-> Take for instance a static profile.html page, a template engine would allow a developer to set a username parameter, that would always be set  to the current user's username.
	-> Server Side Template Injection, is when a user is able to pass in a parameter that can control the template engine that is running on the server.
	-> This introduces a vulnerability, as it allows a hacker to inject template code into the website. The effects of this can be devastating, from XSS, all the way to RCE.
	-> Note: Different template engines have different injection payloads, however usually you can test for SSTI using {{2+2}} as a test.

	Manual Exploitation:
		-> There is a prompt, if you submit name, it will output Hello <name>!
		-> checking for SSTI by giving {{2+2}} as input will return hello 4! as output.
		-> Now we can use swisskyrepo github for payloads.
			1. {{ ''.__class__.__mro__[2].__subclasses__()[40]()(<file>).read()}}
			-> This payload can help us to read files on the server. 
			-> This payload loads the file object in python, from there we can use basic file operations.
			2. {{config.__class__.__init__.__globals__['os'].popen(<command>).read()}}
			-> This payload can execute the commands on the server.
			-> This payload imports the os module, and run a command using popen method.

	Automatic Exploitation
		-> tplmap tool in githhub.
		-> install it
		-> Usage:
			GET: tplmap -u <url>/?<vulnparam>
			POST:tplmap -u <url> -d '<vulnparam>'

		Example: for catting out /etc/passwd:
		>tplmap -u http://10.10.10.10:5000/ -d 'noot' --os-cmd "cat /etc/passwd"


CSRF (Cross Site Request Forgery)
	-> Cross Site Request Forgery, known as CSRF occurs when a user visits a page on a site, that performs an action on a different site.
	-> For instance, let's say a user clicks a link to a website created by a hacker, on the website would be an html tag such as <img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">  which would change the account email on the vulnerable website to "pwned@evil-user.net".
	-> CSRF works because it's the victim making the request not the site, so all the site sees is a normal user making a normal request.

	Automatic Exploitation:
		-> Once again, there is a nice automated scanner, which tests if a site is vulnerable to CSRF. this tool is known as xsrfprobe and can be install via pip using pip3 install xsrfprobe

JWT (JSON Web Tokens)
	-> Json Web Token's are a fairly interesting case, as it isn't a vulnerability itself. Infact, it's a fairly popular, and if done right very secure method of authentication.
	-> The basic structure of a JWT is this, it goes "header.payload.secret", the secret is only known to the server, and is used to make sure that data wasn't changed along the way. 
	-> Everything is then base64 encoded. so an example JWT token would look like 
	"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
	-> Meaning that if we are able to control the secret, we can effectively control the data. 
	-> To be able to do this we have to understand how the secret is calculated. 
	-> This requires knowing the structure of the header, a typical JWT header looks like this {"typ":"JWT","alg":"RS256"}.
	-> We're interested in the alg field. RS256 uses a private RSA key that's only available to the server, so that's not vulnerable.
	-> However, We can change that field to HS256, This is calculated using the server's public key, which in certain circumstances we may have access too.

	Manual Exploitation
	Refer to Section 3 -JWT Manual exploitation task 12 of Room ZTH: Obscure Web vulns


JWT - Continued ('None' Vulnerability)
	 -> Unfortunately certain JWT libraries clearly didn't read the RFC, allowing a vulnerability where an attacker can switch to the None algorithm, in the same way one switches to RS256 to HS255, and have the token be completely valid without even needing to calculate a secret.

	 Manual Exploitation:
	 -> Change the algo to none, in payload part, change the user to admin ..done and get rid of the signature.

	 Automatic Exploitation:
	 -> There is no tool that can check the library, get the token, and make sure this is vulnerable. There is no tool that can check the library, get the token, and make sure this is vulnerable.
	 -> The header for each JWT none vuln though is the same, which can help you out. 
	 -> Here's the header eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0 
	 	Which decodes to {"type": "JWT", "alg": "none"}
	 	